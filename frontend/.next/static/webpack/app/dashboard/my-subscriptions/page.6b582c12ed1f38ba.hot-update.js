"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/my-subscriptions/page",{

/***/ "(app-pages-browser)/./src/lib/utils/generateInvoicePdf.ts":
/*!*********************************************!*\
  !*** ./src/lib/utils/generateInvoicePdf.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateInvoicePdf: function() { return /* binding */ generateInvoicePdf; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n// src/lib/utils/generateInvoicePdf.ts\n// Génération de facture PDF côté client avec jsPDF\n// npm install jspdf\n\n// ─── Couleurs ─────────────────────────────────────────────────────────────────\nconst COLORS = {\n    gold: [\n        217,\n        202,\n        65\n    ],\n    goldLight: [\n        245,\n        242,\n        200\n    ],\n    dark: [\n        30,\n        30,\n        30\n    ],\n    gray: [\n        120,\n        120,\n        120\n    ],\n    lightGray: [\n        240,\n        240,\n        240\n    ],\n    white: [\n        255,\n        255,\n        255\n    ],\n    primary: [\n        37,\n        99,\n        235\n    ]\n};\n// ─── Helpers ──────────────────────────────────────────────────────────────────\nfunction formatDate(dateStr) {\n    let locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"fr-FR\";\n    const d = new Date(dateStr);\n    return d.toLocaleDateString(locale, {\n        day: \"2-digit\",\n        month: \"long\",\n        year: \"numeric\"\n    });\n}\nfunction formatCurrency(amount) {\n    return \"\".concat(amount.toFixed(2), \" €\");\n}\nfunction zeroPad(num) {\n    let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n    return String(num).padStart(size, \"0\");\n}\n// ─── Générateur principal ──────────────────────────────────────────────────────\n/**\n * Génère un PDF de facture fidèle au modèle Excel et le télécharge automatiquement.\n *\n * @param subscription  - Données de la souscription\n * @param tenant        - Informations de l'entreprise prestataire\n * @param options       - Options supplémentaires (logo, numéro de facture…)\n */ function generateInvoicePdf(subscription, tenant) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        orientation: \"portrait\",\n        unit: \"mm\",\n        format: \"a4\"\n    });\n    // Dimensions page\n    const PW = doc.internal.pageSize.getWidth(); // 210 mm\n    const PH = doc.internal.pageSize.getHeight(); // 297 mm\n    const MARGIN = 15;\n    const CONTENT_W = PW - MARGIN * 2;\n    var _subscription_id, _options_invoiceNumber;\n    // ── Numéro de facture ───────────────────────────────────────────────────────\n    const invoiceNumber = (_options_invoiceNumber = options.invoiceNumber) !== null && _options_invoiceNumber !== void 0 ? _options_invoiceNumber : zeroPad((_subscription_id = subscription.id) !== null && _subscription_id !== void 0 ? _subscription_id : 1);\n    // ── Montant ─────────────────────────────────────────────────────────────────\n    const amount = Number(subscription.paymentAmount) || 0;\n    // ── Description de la prestation ────────────────────────────────────────────\n    const description = \"Abonnement \".concat(subscription.offerName, \" — \").concat(formatDate(subscription.subscriptionStartDate), \" → \").concat(formatDate(subscription.subscriptionEndDate), \" (\").concat(subscription.daysSubscribed, \" jours)\");\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 1. EN-TÊTE — logo + titre FACTURE\n    // ═══════════════════════════════════════════════════════════════════════════\n    /* Bloc logo (gauche)\n  if (options.logoBase64) {\n    try {\n      doc.addImage(options.logoBase64, 'gba.PNG', MARGIN, 12, 40, 20);\n    } catch {\n      // Ignore les erreurs de logo\n    }\n  } else {\n    // Placeholder gris clair\n    doc.setFillColor(...COLORS.lightGray);\n    doc.roundedRect(MARGIN, 12, 40, 20, 2, 2, 'F');\n    doc.setFontSize(7);\n    doc.setTextColor(...COLORS.gray);\n    doc.text('Logo', MARGIN + 20, 23, { align: 'center' });\n  }*/ // 1. EN-TÊTE — logo + titre FACTURE\n    if (options.logoBase64) {\n        try {\n            // On utilise 'JPEG' ou 'PNG' (jsPDF gère les deux via 'JPEG' souvent par défaut)\n            // Les coordonnées : X=MARGIN, Y=10, Largeur=45, Hauteur=20\n            doc.addImage(options.logoBase64, \"JPEG\", MARGIN, 10, 45, 20);\n        } catch (e) {\n            console.error(\"Erreur logo:\", e);\n        }\n    } else {\n        // Placeholder si pas de logo\n        doc.setFillColor(...COLORS.lightGray);\n        doc.roundedRect(MARGIN, 12, 40, 20, 2, 2, \"F\");\n    }\n    // Titre \"Facture\" (droite) – grande police\n    doc.setFontSize(36);\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setTextColor(...COLORS.dark);\n    doc.text(\"Facture\", PW - MARGIN, 26, {\n        align: \"right\"\n    });\n    const headerBottom = 36;\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 2. IDENTITÉ PRESTATAIRE (gauche) + MÉTA-DONNÉES FACTURE (droite)\n    // ═══════════════════════════════════════════════════════════════════════════\n    let leftY = headerBottom + 4;\n    let rightY = headerBottom + 4;\n    // — Prestataire —\n    doc.setFontSize(11);\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setTextColor(...COLORS.dark);\n    doc.text(\"Giselle Brand Agency\", MARGIN, leftY);\n    leftY += 5;\n    doc.setFontSize(8);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setTextColor(...COLORS.gray);\n    doc.text(\"Entreprise Individuelle\", MARGIN, leftY);\n    leftY += 4;\n    doc.setFontSize(8);\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setTextColor(...COLORS.dark);\n    doc.text(\"SIREN/SIRET : 999327844\", MARGIN, leftY);\n    leftY += 5;\n    // — Méta-données (date / n° / id client) —\n    const META_LABEL_X = PW - MARGIN - 55;\n    const META_VALUE_X = PW - MARGIN;\n    const metaRows = [\n        [\n            \"Date :\",\n            formatDate(subscription.paymentDate)\n        ],\n        [\n            \"Facture # :\",\n            invoiceNumber\n        ],\n        // ['ID Client :', subscription.offerName],\n        [\n            \"Client :\",\n            tenant.companyName\n        ]\n    ];\n    for (const [label, value] of metaRows){\n        doc.setFontSize(9);\n        doc.setFont(\"helvetica\", \"bold\");\n        doc.setTextColor(...COLORS.dark);\n        doc.text(label, META_LABEL_X, rightY, {\n            align: \"right\"\n        });\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(...COLORS.gray);\n        doc.text(value, META_VALUE_X, rightY, {\n            align: \"right\"\n        });\n        rightY += 5;\n    }\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 3. BLOC \"POUR\" — Destinataire (client)\n    // ═══════════════════════════════════════════════════════════════════════════\n    const billingY = Math.max(leftY, rightY) + 6;\n    doc.setFontSize(9);\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setTextColor(...COLORS.dark);\n    doc.text(\"Pour :\", MARGIN + 20, billingY, {\n        align: \"right\"\n    });\n    const clientLines = [];\n    if (tenant.companyName) clientLines.push(tenant.companyName);\n    if (tenant.address1) clientLines.push(tenant.address1);\n    if (tenant.address2) clientLines.push(tenant.address2);\n    if (tenant.phone) clientLines.push(tenant.phone);\n    if (tenant.email) clientLines.push(tenant.email);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setTextColor(...COLORS.gray);\n    let clientY = billingY;\n    for (const line of clientLines){\n        doc.text(line, MARGIN + 22, clientY);\n        clientY += 4.5;\n    }\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 4. TABLEAU \"NOM / POSTE / CONDITIONS DE PAIEMENT / DATE\"\n    // ═══════════════════════════════════════════════════════════════════════════\n    const TABLE1_Y = Math.max(clientY, billingY) + 6;\n    const ROW_H = 8;\n    const TABLE1_COLS = [\n        50,\n        60,\n        30\n    ]; // largeurs colonnes\n    const TABLE1_HEADERS = [\n        \"NOM\",\n        \"CONDITIONS DE PAIEMENT\",\n        \"DATE\"\n    ];\n    // En-tête jaune\n    _drawTableHeader(doc, MARGIN, TABLE1_Y, TABLE1_COLS, TABLE1_HEADERS);\n    // Ligne de données\n    const paymentCondition = _mapPaymentMethod(subscription.paymentMethod);\n    const dueDate = formatDate(subscription.subscriptionEndDate);\n    _drawTableRow(doc, MARGIN, TABLE1_Y + ROW_H, TABLE1_COLS, [\n        tenant.companyName,\n        paymentCondition,\n        dueDate\n    ]);\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 5. TABLEAU \"QUANTITÉ / DESCRIPTION / PRIX UNITAIRE / TOTAL\"\n    // ═══════════════════════════════════════════════════════════════════════════\n    const TABLE2_Y = TABLE1_Y + ROW_H * 2 + 8;\n    const TABLE2_COLS = [\n        15,\n        95,\n        35,\n        35\n    ];\n    const TABLE2_HEADERS = [\n        \"QT\\xc9\",\n        \"DESCRIPTION\",\n        \"PRIX UNITAIRE\",\n        \"TOTAL\"\n    ];\n    _drawTableHeader(doc, MARGIN, TABLE2_Y, TABLE2_COLS, TABLE2_HEADERS);\n    // Ligne de prestation\n    _drawTableRow(doc, MARGIN, TABLE2_Y + ROW_H, TABLE2_COLS, [\n        \"1\",\n        //description,\n        subscription.offerName,\n        formatCurrency(amount),\n        formatCurrency(amount)\n    ]);\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 6. BLOC TOTAUX (droite)\n    // ═══════════════════════════════════════════════════════════════════════════\n    const TOTAL_Y = TABLE2_Y + ROW_H * 2 + 4;\n    // Dans la section 6. BLOC TOTAUX\n    const TOTAL_VALUE_X = PW - MARGIN; // Reste correct (195mm)\n    const TOTAL_LABEL_X = TOTAL_VALUE_X - 35; // Aligné sur la colonne TOTAL\n    const totalsRows = [\n        [\n            \"Total HT\",\n            formatCurrency(amount),\n            false\n        ],\n        [\n            \"TVA*\",\n            \"N.A.\",\n            false\n        ],\n        [\n            \"Total TTC\",\n            formatCurrency(amount),\n            true\n        ]\n    ];\n    let totalRowY = TOTAL_Y;\n    for (const [label, value, isBold] of totalsRows){\n        // Fond sur ligne Total TTC\n        if (isBold) {\n            doc.setFillColor(...COLORS.gold);\n            doc.rect(TOTAL_LABEL_X + 5, totalRowY - 5, 40 + 4 + 4, 7, \"F\");\n        }\n        doc.setFontSize(9);\n        doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\n        doc.setTextColor(...COLORS.dark);\n        doc.text(label, TOTAL_LABEL_X, totalRowY, {\n            align: \"right\"\n        });\n        doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\n        doc.setTextColor(isBold ? COLORS.primary[0] : COLORS.dark[0], isBold ? COLORS.primary[1] : COLORS.dark[1], isBold ? COLORS.primary[2] : COLORS.dark[2]);\n        doc.text(value, TOTAL_VALUE_X, totalRowY, {\n            align: \"right\"\n        });\n        totalRowY += 7;\n    }\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 7. MENTION TVA\n    // ═══════════════════════════════════════════════════════════════════════════\n    const vatY = totalRowY + 4;\n    doc.setFontSize(7.5);\n    doc.setFont(\"helvetica\", \"italic\");\n    doc.setTextColor(...COLORS.gray);\n    var _tenant_vatMention;\n    const vatText = (_tenant_vatMention = tenant.vatMention) !== null && _tenant_vatMention !== void 0 ? _tenant_vatMention : \"*TVA non applicable, en application de l'article 293B du Code G\\xe9n\\xe9ral des Imp\\xf4ts\";\n    const vatLines = doc.splitTextToSize(vatText, CONTENT_W);\n    doc.text(vatLines, MARGIN, vatY);\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 8. PIED DE PAGE — \"MERCI !\" + coordonnées\n    // ═══════════════════════════════════════════════════════════════════════════\n    const FOOTER_Y = PH - 28;\n    // Trait de séparation\n    doc.setDrawColor(...COLORS.gold);\n    doc.setLineWidth(0.8);\n    doc.line(MARGIN, FOOTER_Y - 4, PW - MARGIN, FOOTER_Y - 4);\n    doc.setFontSize(13);\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setTextColor(...COLORS.dark);\n    doc.text(\"MERCI !\", PW / 2, FOOTER_Y + 4, {\n        align: \"center\"\n    });\n    // Coordonnées\n    const footerParts = [];\n    // if (tenant.address1) footerParts.push(tenant.address1);\n    footerParts.push(\"Giselle Brand Agency - Palavas-Les-Flots - hello.gisellebrandagency@outlook.fr\");\n    doc.setFontSize(8);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setTextColor(...COLORS.gray);\n    doc.text(footerParts.join(\"  •  \"), PW / 2, FOOTER_Y + 10, {\n        align: \"center\"\n    });\n    // ═══════════════════════════════════════════════════════════════════════════\n    // 9. TÉLÉCHARGEMENT\n    // ═══════════════════════════════════════════════════════════════════════════\n    const filename = \"Facture_\".concat(invoiceNumber, \"_\").concat(subscription.offerName.replace(/\\s+/g, \"_\"), \".pdf\");\n    doc.save(filename);\n}\n// ─── Helpers internes ─────────────────────────────────────────────────────────\nfunction _drawTableHeader(doc, x, y, cols, headers) {\n    const ROW_H = 8;\n    let cx = x;\n    for(let i = 0; i < cols.length; i++){\n        // Fond jaune\n        doc.setFillColor(...COLORS.gold);\n        doc.rect(cx, y, cols[i], ROW_H, \"F\");\n        // Bordure\n        doc.setDrawColor(200, 190, 40);\n        doc.setLineWidth(0.2);\n        doc.rect(cx, y, cols[i], ROW_H, \"S\");\n        // Texte centré\n        doc.setFontSize(8.5);\n        doc.setFont(\"helvetica\", \"bold\");\n        doc.setTextColor(...COLORS.dark);\n        doc.text(headers[i], cx + cols[i] / 2, y + 5.2, {\n            align: \"center\"\n        });\n        cx += cols[i];\n    }\n}\n/*\nfunction _drawTableRow(\n  doc: jsPDF,\n  x: number,\n  y: number,\n  cols: number[],\n  values: string[]\n): void {\n  const ROW_H = 8;\n  let cx = x;\n\n  for (let i = 0; i < cols.length; i++) {\n    // Fond blanc léger\n    doc.setFillColor(...COLORS.white);\n    doc.rect(cx, y, cols[i], ROW_H, 'F');\n\n    // Bordure fine\n    doc.setDrawColor(220, 220, 220);\n    doc.setLineWidth(0.15);\n    doc.rect(cx, y, cols[i], ROW_H, 'S');\n\n    // Texte (avec wrap si nécessaire)\n    doc.setFontSize(8.5);\n    doc.setFont('helvetica', 'normal');\n    doc.setTextColor(...COLORS.dark);\n\n    const align = i === 0 ? 'center' : i >= cols.length - 2 ? 'right' : 'left';\n    const textX =\n      align === 'center' ? cx + cols[i] / 2 : align === 'right' ? cx + cols[i] - 2 : cx + 2;\n\n    // Wrap sur la colonne description (index 1 dans le 2e tableau)\n    if (values[i].length > 30 && cols[i] > 50) {\n      const lines = doc.splitTextToSize(values[i], cols[i] - 4);\n      doc.text(lines[0], textX, y + 5.2, { align });\n    } else {\n      doc.text(values[i], textX, y + 5.2, { align });\n    }\n\n    cx += cols[i];\n  }\n}*/ function _drawTableRow(doc, x, y, cols, values) {\n    const ROW_H = 8;\n    let cx = x;\n    for(let i = 0; i < cols.length; i++){\n        doc.setFillColor(...COLORS.white);\n        doc.rect(cx, y, cols[i], ROW_H, \"F\");\n        doc.setDrawColor(220, 220, 220);\n        doc.setLineWidth(0.15);\n        doc.rect(cx, y, cols[i], ROW_H, \"S\");\n        doc.setFontSize(8); // Taille légèrement réduite pour la sécurité\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(...COLORS.dark);\n        // Détermination de l'alignement\n        const align = i === 0 || i === 1 ? \"left\" : \"right\";\n        const textX = align === \"left\" ? cx + 2 : cx + cols[i] - 2;\n        // Gestion du texte long (Description)\n        const maxWidth = cols[i] - 4;\n        const textLines = doc.splitTextToSize(values[i], maxWidth);\n        // On n'affiche que la première ligne si ça dépasse, \n        // ou on réduit la police si c'est la description\n        if (textLines.length > 1 && i === 1) {\n            doc.setFontSize(7);\n        }\n        doc.text(textLines[0], textX, y + 5.2, {\n            align\n        });\n        cx += cols[i];\n    }\n}\nfunction _mapPaymentMethod(method) {\n    const map = {\n        carte_bancaire: \"Carte bancaire\",\n        virement: \"Virement bancaire\",\n        prelevement: \"Pr\\xe9l\\xe8vement automatique\",\n        cheque: \"Ch\\xe8que\",\n        non_specifie: \"D\\xfb \\xe0 r\\xe9ception de la facture\"\n    };\n    var _map_;\n    return (_map_ = map[method !== null && method !== void 0 ? method : \"\"]) !== null && _map_ !== void 0 ? _map_ : \"D\\xfb \\xe0 r\\xe9ception de la facture\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMvZ2VuZXJhdGVJbnZvaWNlUGRmLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsc0NBQXNDO0FBQ3RDLG1EQUFtRDtBQUNuRCxvQkFBb0I7QUFFTTtBQWlDMUIsaUZBQWlGO0FBRWpGLE1BQU1DLFNBQVM7SUFDYkMsTUFBTTtRQUFDO1FBQUs7UUFBSztLQUFHO0lBQ3BCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDMUJDLE1BQU07UUFBQztRQUFJO1FBQUk7S0FBRztJQUNsQkMsTUFBTTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3JCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDMUJDLE9BQU87UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN0QkMsU0FBUztRQUFDO1FBQUk7UUFBSTtLQUFJO0FBQ3hCO0FBRUEsaUZBQWlGO0FBRWpGLFNBQVNDLFdBQVdDLE9BQXNCO1FBQUVDLFNBQUFBLGlFQUFTO0lBQ25ELE1BQU1DLElBQUksSUFBSUMsS0FBS0g7SUFDbkIsT0FBT0UsRUFBRUUsa0JBQWtCLENBQUNILFFBQVE7UUFBRUksS0FBSztRQUFXQyxPQUFPO1FBQVFDLE1BQU07SUFBVTtBQUN2RjtBQUVBLFNBQVNDLGVBQWVDLE1BQWM7SUFDcEMsT0FBTyxHQUFxQixPQUFsQkEsT0FBT0MsT0FBTyxDQUFDLElBQUc7QUFDOUI7QUFFQSxTQUFTQyxRQUFRQyxHQUFXO1FBQUVDLE9BQUFBLGlFQUFPO0lBQ25DLE9BQU9DLE9BQU9GLEtBQUtHLFFBQVEsQ0FBQ0YsTUFBTTtBQUNwQztBQUVBLGtGQUFrRjtBQUVsRjs7Ozs7O0NBTUMsR0FDTSxTQUFTRyxtQkFDZEMsWUFBMEIsRUFDMUJDLE1BQWtCO1FBQ2xCQyxVQUFBQSxpRUFBMEIsQ0FBQztJQUUzQixNQUFNQyxNQUFNLElBQUk5Qiw2Q0FBS0EsQ0FBQztRQUFFK0IsYUFBYTtRQUFZQyxNQUFNO1FBQU1DLFFBQVE7SUFBSztJQUUxRSxrQkFBa0I7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Q0FBQ2dCLE1BQU0sQ0FBQ0YsRUFBRSxFQUFFSTtRQUVqRCxxREFBcUQ7UUFDckQsaURBQWlEO1FBQ2pELElBQUlDLFVBQVVKLE1BQU0sR0FBRyxLQUFLRCxNQUFNLEdBQUc7WUFDakM1RixJQUFJNEIsV0FBVyxDQUFDO1FBQ3BCO1FBRUE1QixJQUFJK0IsSUFBSSxDQUFDa0UsU0FBUyxDQUFDLEVBQUUsRUFBRUYsT0FBT1AsSUFBSSxLQUFLO1lBQUV4RDtRQUFNO1FBRS9DMkQsTUFBTUYsSUFBSSxDQUFDRyxFQUFFO0lBQ2Y7QUFDRjtBQUVBLFNBQVNoQyxrQkFBa0JzQyxNQUFlO0lBQ3hDLE1BQU1DLE1BQThCO1FBQ2xDQyxnQkFBZ0I7UUFDaEJDLFVBQVU7UUFDVkMsYUFBYTtRQUNiQyxRQUFRO1FBQ1JDLGNBQWM7SUFDaEI7UUFDT0w7SUFBUCxPQUFPQSxDQUFBQSxRQUFBQSxHQUFHLENBQUNELG1CQUFBQSxvQkFBQUEsU0FBVSxHQUFHLGNBQWpCQyxtQkFBQUEsUUFBcUI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi91dGlscy9nZW5lcmF0ZUludm9pY2VQZGYudHM/NzllNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL3V0aWxzL2dlbmVyYXRlSW52b2ljZVBkZi50c1xuLy8gR8OpbsOpcmF0aW9uIGRlIGZhY3R1cmUgUERGIGPDtHTDqSBjbGllbnQgYXZlYyBqc1BERlxuLy8gbnBtIGluc3RhbGwganNwZGZcblxuaW1wb3J0IGpzUERGIGZyb20gJ2pzcGRmJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgR0JBX0xPR09fQkFTRTY0IH0gZnJvbSAnLi9sb2dvJzsgLy8gSW1wb3J0ZXIgbGUgbG9nb1xuXG4vLyDilIDilIDilIAgVHlwZXMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuYW50SW5mbyB7XG4gIC8qKiBOb20gZGUgbGEgc29jacOpdMOpIG91IGRlIGwnZW50cmVwcmVuZXVyICovXG4gIGNvbXBhbnlOYW1lOiBzdHJpbmc7XG4gIC8qKiBTb3VzLXRpdHJlIC8gc3RhdHV0IGzDqWdhbCAoZXg6IFwiRnJlZWxhbmNlIC0gRW50cmVwcmVuZXVyIEluZGl2aWR1ZWxcIikgKi9cbiAgbGVnYWxTdGF0dXM/OiBzdHJpbmc7XG4gIC8qKiBOdW3DqXJvIFNJUkVOL1NJUkVUICovXG4gIHNpcmVuU2lyZXQ/OiBzdHJpbmc7XG4gIC8qKiBBZHJlc3NlIGNvbXBsw6h0ZSAqL1xuICBhZGRyZXNzMT86IHN0cmluZztcbiAgYWRkcmVzczI/OiBzdHJpbmc7XG4gIC8qKiBUw6lsw6lwaG9uZSAqL1xuICBwaG9uZT86IHN0cmluZztcbiAgLyoqIEVtYWlsICovXG4gIGVtYWlsPzogc3RyaW5nO1xuICAvKiogTm9tIGR1IGNvbnRhY3QgcHJpbmNpcGFsICovXG4gIGNvbnRhY3ROYW1lPzogc3RyaW5nO1xuICAvKiogTWVudGlvbiBUVkEgKGxhaXNzZXogdmlkZSBwb3VyIGF1dG8tbWVudGlvbiBhcnQuIDI5M0IpICovXG4gIHZhdE1lbnRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW52b2ljZU9wdGlvbnMge1xuICAvKiogTnVtw6lybyBkZSBmYWN0dXJlIChhdXRvLWfDqW7DqXLDqSDDoCBwYXJ0aXIgZGUgbCdpZCBzaSBhYnNlbnQpICovXG4gIGludm9pY2VOdW1iZXI/OiBzdHJpbmc7XG4gIC8qKiBMb2dvIGVuIGJhc2U2NCAoZGF0YTppbWFnZS9wbmc7YmFzZTY0LC4uLikgKi9cbiAgbG9nb0Jhc2U2ND86IHN0cmluZztcbn1cblxuLy8g4pSA4pSA4pSAIENvdWxldXJzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG5jb25zdCBDT0xPUlMgPSB7XG4gIGdvbGQ6IFsyMTcsIDIwMiwgNjVdIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgICAgICAgLy8gI0Q5Q0E0MSDigJMgZW4tdMOqdGUgdGFibGVhdXhcbiAgZ29sZExpZ2h0OiBbMjQ1LCAyNDIsIDIwMF0gYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCAvLyBmb25kIGxpZ25lcyBhbHRlcm7DqWVzXG4gIGRhcms6IFszMCwgMzAsIDMwXSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGdyYXk6IFsxMjAsIDEyMCwgMTIwXSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGxpZ2h0R3JheTogWzI0MCwgMjQwLCAyNDBdIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIHByaW1hcnk6IFszNywgOTksIDIzNV0gYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCAgICAgLy8gYmxldSBwb3VyIG1vbnRhbnRzXG59O1xuXG4vLyDilIDilIDilIAgSGVscGVycyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlU3RyOiBzdHJpbmcgfCBEYXRlLCBsb2NhbGUgPSAnZnItRlInKTogc3RyaW5nIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcobG9jYWxlLCB7IGRheTogJzItZGlnaXQnLCBtb250aDogJ2xvbmcnLCB5ZWFyOiAnbnVtZXJpYycgfSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KGFtb3VudDogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2Ftb3VudC50b0ZpeGVkKDIpfSDigqxgO1xufVxuXG5mdW5jdGlvbiB6ZXJvUGFkKG51bTogbnVtYmVyLCBzaXplID0gMyk6IHN0cmluZyB7XG4gIHJldHVybiBTdHJpbmcobnVtKS5wYWRTdGFydChzaXplLCAnMCcpO1xufVxuXG4vLyDilIDilIDilIAgR8OpbsOpcmF0ZXVyIHByaW5jaXBhbCDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuLyoqXG4gKiBHw6luw6hyZSB1biBQREYgZGUgZmFjdHVyZSBmaWTDqGxlIGF1IG1vZMOobGUgRXhjZWwgZXQgbGUgdMOpbMOpY2hhcmdlIGF1dG9tYXRpcXVlbWVudC5cbiAqXG4gKiBAcGFyYW0gc3Vic2NyaXB0aW9uICAtIERvbm7DqWVzIGRlIGxhIHNvdXNjcmlwdGlvblxuICogQHBhcmFtIHRlbmFudCAgICAgICAgLSBJbmZvcm1hdGlvbnMgZGUgbCdlbnRyZXByaXNlIHByZXN0YXRhaXJlXG4gKiBAcGFyYW0gb3B0aW9ucyAgICAgICAtIE9wdGlvbnMgc3VwcGzDqW1lbnRhaXJlcyAobG9nbywgbnVtw6lybyBkZSBmYWN0dXJl4oCmKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJbnZvaWNlUGRmKFxuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbixcbiAgdGVuYW50OiBUZW5hbnRJbmZvLFxuICBvcHRpb25zOiBJbnZvaWNlT3B0aW9ucyA9IHt9XG4pOiB2b2lkIHtcbiAgY29uc3QgZG9jID0gbmV3IGpzUERGKHsgb3JpZW50YXRpb246ICdwb3J0cmFpdCcsIHVuaXQ6ICdtbScsIGZvcm1hdDogJ2E0JyB9KTtcblxuICAvLyBEaW1lbnNpb25zIHBhZ2VcbiAgY29uc3QgUFcgPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTsgICAvLyAyMTAgbW1cbiAgY29uc3QgUEggPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0SGVpZ2h0KCk7ICAvLyAyOTcgbW1cbiAgY29uc3QgTUFSR0lOID0gMTU7XG4gIGNvbnN0IENPTlRFTlRfVyA9IFBXIC0gTUFSR0lOICogMjtcblxuICAvLyDilIDilIAgTnVtw6lybyBkZSBmYWN0dXJlIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuICBjb25zdCBpbnZvaWNlTnVtYmVyID1cbiAgICBvcHRpb25zLmludm9pY2VOdW1iZXIgPz8gemVyb1BhZChzdWJzY3JpcHRpb24uaWQgPz8gMSk7XG5cbiAgLy8g4pSA4pSAIE1vbnRhbnQg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG4gIGNvbnN0IGFtb3VudCA9IE51bWJlcihzdWJzY3JpcHRpb24ucGF5bWVudEFtb3VudCkgfHwgMDtcblxuICAvLyDilIDilIAgRGVzY3JpcHRpb24gZGUgbGEgcHJlc3RhdGlvbiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBgQWJvbm5lbWVudCAke3N1YnNjcmlwdGlvbi5vZmZlck5hbWV9IOKAlCAke2Zvcm1hdERhdGUoXG4gICAgc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvblN0YXJ0RGF0ZVxuICApfSDihpIgJHtmb3JtYXREYXRlKHN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25FbmREYXRlKX0gKCR7c3Vic2NyaXB0aW9uLmRheXNTdWJzY3JpYmVkfSBqb3VycylgO1xuXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuICAvLyAxLiBFTi1Uw4pURSDigJQgbG9nbyArIHRpdHJlIEZBQ1RVUkVcbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG5cbiAgLyogQmxvYyBsb2dvIChnYXVjaGUpXG4gIGlmIChvcHRpb25zLmxvZ29CYXNlNjQpIHtcbiAgICB0cnkge1xuICAgICAgZG9jLmFkZEltYWdlKG9wdGlvbnMubG9nb0Jhc2U2NCwgJ2diYS5QTkcnLCBNQVJHSU4sIDEyLCA0MCwgMjApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIGxlcyBlcnJldXJzIGRlIGxvZ29cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUGxhY2Vob2xkZXIgZ3JpcyBjbGFpclxuICAgIGRvYy5zZXRGaWxsQ29sb3IoLi4uQ09MT1JTLmxpZ2h0R3JheSk7XG4gICAgZG9jLnJvdW5kZWRSZWN0KE1BUkdJTiwgMTIsIDQwLCAyMCwgMiwgMiwgJ0YnKTtcbiAgICBkb2Muc2V0Rm9udFNpemUoNyk7XG4gICAgZG9jLnNldFRleHRDb2xvciguLi5DT0xPUlMuZ3JheSk7XG4gICAgZG9jLnRleHQoJ0xvZ28nLCBNQVJHSU4gKyAyMCwgMjMsIHsgYWxpZ246ICdjZW50ZXInIH0pO1xuICB9Ki9cbi8vIDEuIEVOLVTDilRFIOKAlCBsb2dvICsgdGl0cmUgRkFDVFVSRVxuICBpZiAob3B0aW9ucy5sb2dvQmFzZTY0KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE9uIHV0aWxpc2UgJ0pQRUcnIG91ICdQTkcnIChqc1BERiBnw6hyZSBsZXMgZGV1eCB2aWEgJ0pQRUcnIHNvdXZlbnQgcGFyIGTDqWZhdXQpXG4gICAgICAvLyBMZXMgY29vcmRvbm7DqWVzIDogWD1NQVJHSU4sIFk9MTAsIExhcmdldXI9NDUsIEhhdXRldXI9MjBcbiAgICAgIGRvYy5hZGRJbWFnZShvcHRpb25zLmxvZ29CYXNlNjQsICdKUEVHJywgTUFSR0lOLCAxMCwgNDUsIDIwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGxvZ286XCIsIGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBQbGFjZWhvbGRlciBzaSBwYXMgZGUgbG9nb1xuICAgIGRvYy5zZXRGaWxsQ29sb3IoLi4uQ09MT1JTLmxpZ2h0R3JheSk7XG4gICAgZG9jLnJvdW5kZWRSZWN0KE1BUkdJTiwgMTIsIDQwLCAyMCwgMiwgMiwgJ0YnKTtcbiAgfVxuXG5cblxuICAvLyBUaXRyZSBcIkZhY3R1cmVcIiAoZHJvaXRlKSDigJMgZ3JhbmRlIHBvbGljZVxuICBkb2Muc2V0Rm9udFNpemUoMzYpO1xuICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ2JvbGQnKTtcbiAgZG9jLnNldFRleHRDb2xvciguLi5DT0xPUlMuZGFyayk7XG4gIGRvYy50ZXh0KCdGYWN0dXJlJywgUFcgLSBNQVJHSU4sIDI2LCB7IGFsaWduOiAncmlnaHQnIH0pO1xuXG4gIGNvbnN0IGhlYWRlckJvdHRvbSA9IDM2O1xuXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuICAvLyAyLiBJREVOVElUw4kgUFJFU1RBVEFJUkUgKGdhdWNoZSkgKyBNw4lUQS1ET05Ow4lFUyBGQUNUVVJFIChkcm9pdGUpXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuXG4gIGxldCBsZWZ0WSA9IGhlYWRlckJvdHRvbSArIDQ7XG4gIGxldCByaWdodFkgPSBoZWFkZXJCb3R0b20gKyA0O1xuXG4gIC8vIOKAlCBQcmVzdGF0YWlyZSDigJRcbiAgZG9jLnNldEZvbnRTaXplKDExKTtcbiAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdib2xkJyk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoLi4uQ09MT1JTLmRhcmspO1xuIGRvYy50ZXh0KFwiR2lzZWxsZSBCcmFuZCBBZ2VuY3lcIiwgTUFSR0lOLCBsZWZ0WSk7XG5cbiAgbGVmdFkgKz0gNTtcbiAgICBkb2Muc2V0Rm9udFNpemUoOCk7XG4gICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKC4uLkNPTE9SUy5ncmF5KTtcbiAgXG5kb2MudGV4dChcIkVudHJlcHJpc2UgSW5kaXZpZHVlbGxlXCIsIE1BUkdJTiwgbGVmdFkpO1xuICAgIGxlZnRZICs9IDQ7XG4gICAgZG9jLnNldEZvbnRTaXplKDgpO1xuICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnYm9sZCcpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoLi4uQ09MT1JTLmRhcmspO1xuICBcbmRvYy50ZXh0KFwiU0lSRU4vU0lSRVQgOiA5OTkzMjc4NDRcIiwgTUFSR0lOLCBsZWZ0WSk7XG4gICAgbGVmdFkgKz0gNTtcblxuXG4gIC8vIOKAlCBNw6l0YS1kb25uw6llcyAoZGF0ZSAvIG7CsCAvIGlkIGNsaWVudCkg4oCUXG4gIGNvbnN0IE1FVEFfTEFCRUxfWCA9IFBXIC0gTUFSR0lOIC0gNTU7XG4gIGNvbnN0IE1FVEFfVkFMVUVfWCA9IFBXIC0gTUFSR0lOO1xuXG4gIGNvbnN0IG1ldGFSb3dzOiBbc3RyaW5nLCBzdHJpbmddW10gPSBbXG4gICAgWydEYXRlIDonLCBmb3JtYXREYXRlKHN1YnNjcmlwdGlvbi5wYXltZW50RGF0ZSldLFxuICAgIFsnRmFjdHVyZSAjIDonLCBpbnZvaWNlTnVtYmVyXSxcbiAgIC8vIFsnSUQgQ2xpZW50IDonLCBzdWJzY3JpcHRpb24ub2ZmZXJOYW1lXSxcbiAgIFsnQ2xpZW50IDonLCB0ZW5hbnQuY29tcGFueU5hbWVdLFxuICBdO1xuXG4gIGZvciAoY29uc3QgW2xhYmVsLCB2YWx1ZV0gb2YgbWV0YVJvd3MpIHtcbiAgICBkb2Muc2V0Rm9udFNpemUoOSk7XG4gICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdib2xkJyk7XG4gICAgZG9jLnNldFRleHRDb2xvciguLi5DT0xPUlMuZGFyayk7XG4gICAgZG9jLnRleHQobGFiZWwsIE1FVEFfTEFCRUxfWCwgcmlnaHRZLCB7IGFsaWduOiAncmlnaHQnIH0pO1xuXG4gICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKC4uLkNPTE9SUy5ncmF5KTtcbiAgICBkb2MudGV4dCh2YWx1ZSwgTUVUQV9WQUxVRV9YLCByaWdodFksIHsgYWxpZ246ICdyaWdodCcgfSk7XG4gICAgcmlnaHRZICs9IDU7XG4gIH1cblxuICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgLy8gMy4gQkxPQyBcIlBPVVJcIiDigJQgRGVzdGluYXRhaXJlIChjbGllbnQpXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuXG4gIGNvbnN0IGJpbGxpbmdZID0gTWF0aC5tYXgobGVmdFksIHJpZ2h0WSkgKyA2O1xuXG4gIGRvYy5zZXRGb250U2l6ZSg5KTtcbiAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdib2xkJyk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoLi4uQ09MT1JTLmRhcmspO1xuICBkb2MudGV4dCgnUG91ciA6JywgTUFSR0lOICsgMjAsIGJpbGxpbmdZLCB7IGFsaWduOiAncmlnaHQnIH0pO1xuXG4gIGNvbnN0IGNsaWVudExpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICBpZiAodGVuYW50LmNvbXBhbnlOYW1lKSBjbGllbnRMaW5lcy5wdXNoKHRlbmFudC5jb21wYW55TmFtZSk7XG4gIGlmICh0ZW5hbnQuYWRkcmVzczEpIGNsaWVudExpbmVzLnB1c2godGVuYW50LmFkZHJlc3MxKTtcbiAgaWYgKHRlbmFudC5hZGRyZXNzMikgY2xpZW50TGluZXMucHVzaCh0ZW5hbnQuYWRkcmVzczIpO1xuICBpZiAodGVuYW50LnBob25lKSBjbGllbnRMaW5lcy5wdXNoKHRlbmFudC5waG9uZSk7XG4gIGlmICh0ZW5hbnQuZW1haWwpIGNsaWVudExpbmVzLnB1c2godGVuYW50LmVtYWlsKTtcblxuICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ25vcm1hbCcpO1xuICBkb2Muc2V0VGV4dENvbG9yKC4uLkNPTE9SUy5ncmF5KTtcbiAgbGV0IGNsaWVudFkgPSBiaWxsaW5nWTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGNsaWVudExpbmVzKSB7XG4gICAgZG9jLnRleHQobGluZSwgTUFSR0lOICsgMjIsIGNsaWVudFkpO1xuICAgIGNsaWVudFkgKz0gNC41O1xuICB9XG5cbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gIC8vIDQuIFRBQkxFQVUgXCJOT00gLyBQT1NURSAvIENPTkRJVElPTlMgREUgUEFJRU1FTlQgLyBEQVRFXCJcbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG5cbiAgY29uc3QgVEFCTEUxX1kgPSBNYXRoLm1heChjbGllbnRZLCBiaWxsaW5nWSkgKyA2O1xuICBjb25zdCBST1dfSCA9IDg7XG4gIGNvbnN0IFRBQkxFMV9DT0xTID0gWzUwLCAgNjAsIDMwXTsgLy8gbGFyZ2V1cnMgY29sb25uZXNcbiAgY29uc3QgVEFCTEUxX0hFQURFUlMgPSBbJ05PTScsICAnQ09ORElUSU9OUyBERSBQQUlFTUVOVCcsICdEQVRFJ107XG5cbiAgLy8gRW4tdMOqdGUgamF1bmVcbiAgX2RyYXdUYWJsZUhlYWRlcihkb2MsIE1BUkdJTiwgVEFCTEUxX1ksIFRBQkxFMV9DT0xTLCBUQUJMRTFfSEVBREVSUyk7XG5cbiAgLy8gTGlnbmUgZGUgZG9ubsOpZXNcbiAgY29uc3QgcGF5bWVudENvbmRpdGlvbiA9IF9tYXBQYXltZW50TWV0aG9kKHN1YnNjcmlwdGlvbi5wYXltZW50TWV0aG9kKTtcbiAgY29uc3QgZHVlRGF0ZSA9IGZvcm1hdERhdGUoc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbkVuZERhdGUpO1xuXG4gIF9kcmF3VGFibGVSb3coZG9jLCBNQVJHSU4sIFRBQkxFMV9ZICsgUk9XX0gsIFRBQkxFMV9DT0xTLCBbXG4gICAgdGVuYW50LmNvbXBhbnlOYW1lLFxuICAgIHBheW1lbnRDb25kaXRpb24sXG4gICAgZHVlRGF0ZSxcbiAgXSk7XG5cbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gIC8vIDUuIFRBQkxFQVUgXCJRVUFOVElUw4kgLyBERVNDUklQVElPTiAvIFBSSVggVU5JVEFJUkUgLyBUT1RBTFwiXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuXG4gIGNvbnN0IFRBQkxFMl9ZID0gVEFCTEUxX1kgKyBST1dfSCAqIDIgKyA4O1xuICBjb25zdCBUQUJMRTJfQ09MUyA9IFsxNSwgOTUsIDM1LCAzNV07XG4gIGNvbnN0IFRBQkxFMl9IRUFERVJTID0gWydRVMOJJywgJ0RFU0NSSVBUSU9OJywgJ1BSSVggVU5JVEFJUkUnLCAnVE9UQUwnXTtcblxuICBfZHJhd1RhYmxlSGVhZGVyKGRvYywgTUFSR0lOLCBUQUJMRTJfWSwgVEFCTEUyX0NPTFMsIFRBQkxFMl9IRUFERVJTKTtcblxuICAvLyBMaWduZSBkZSBwcmVzdGF0aW9uXG4gIF9kcmF3VGFibGVSb3coZG9jLCBNQVJHSU4sIFRBQkxFMl9ZICsgUk9XX0gsIFRBQkxFMl9DT0xTLCBbXG4gICAgJzEnLFxuICAgIC8vZGVzY3JpcHRpb24sXG4gICAgc3Vic2NyaXB0aW9uLm9mZmVyTmFtZSxcbiAgICBmb3JtYXRDdXJyZW5jeShhbW91bnQpLFxuICAgIGZvcm1hdEN1cnJlbmN5KGFtb3VudCksXG4gIF0pO1xuXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuICAvLyA2LiBCTE9DIFRPVEFVWCAoZHJvaXRlKVxuICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuICBjb25zdCBUT1RBTF9ZID0gVEFCTEUyX1kgKyBST1dfSCAqIDIgKyA0O1xuXG5cbiAgLy8gRGFucyBsYSBzZWN0aW9uIDYuIEJMT0MgVE9UQVVYXG5jb25zdCBUT1RBTF9WQUxVRV9YID0gUFcgLSBNQVJHSU47IC8vIFJlc3RlIGNvcnJlY3QgKDE5NW1tKVxuY29uc3QgVE9UQUxfTEFCRUxfWCA9IFRPVEFMX1ZBTFVFX1ggLSAzNTsgLy8gQWxpZ27DqSBzdXIgbGEgY29sb25uZSBUT1RBTFxuXG4gIGNvbnN0IHRvdGFsc1Jvd3M6IFtzdHJpbmcsIHN0cmluZywgYm9vbGVhbl1bXSA9IFtcbiAgICBbJ1RvdGFsIEhUJywgZm9ybWF0Q3VycmVuY3koYW1vdW50KSwgZmFsc2VdLFxuICAgIFsnVFZBKicsICdOLkEuJywgZmFsc2VdLFxuICAgIFsnVG90YWwgVFRDJywgZm9ybWF0Q3VycmVuY3koYW1vdW50KSwgdHJ1ZV0sXG4gIF07XG5cbiAgbGV0IHRvdGFsUm93WSA9IFRPVEFMX1k7XG4gIGZvciAoY29uc3QgW2xhYmVsLCB2YWx1ZSwgaXNCb2xkXSBvZiB0b3RhbHNSb3dzKSB7XG4gICAgLy8gRm9uZCBzdXIgbGlnbmUgVG90YWwgVFRDXG4gICAgaWYgKGlzQm9sZCkge1xuICAgICAgZG9jLnNldEZpbGxDb2xvciguLi5DT0xPUlMuZ29sZCk7XG4gICAgICBkb2MucmVjdChUT1RBTF9MQUJFTF9YICs1LCB0b3RhbFJvd1kgLSA1LCA0MCArIDQgKyA0LCA3LCAnRicpO1xuICAgIH1cblxuICAgIGRvYy5zZXRGb250U2l6ZSg5KTtcbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgaXNCb2xkID8gJ2JvbGQnIDogJ25vcm1hbCcpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoLi4uQ09MT1JTLmRhcmspO1xuICAgIGRvYy50ZXh0KGxhYmVsLCBUT1RBTF9MQUJFTF9YLCB0b3RhbFJvd1ksIHsgYWxpZ246ICdyaWdodCcgfSk7XG5cbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgaXNCb2xkID8gJ2JvbGQnIDogJ25vcm1hbCcpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoaXNCb2xkID8gQ09MT1JTLnByaW1hcnlbMF0gOiBDT0xPUlMuZGFya1swXSwgaXNCb2xkID8gQ09MT1JTLnByaW1hcnlbMV0gOiBDT0xPUlMuZGFya1sxXSwgaXNCb2xkID8gQ09MT1JTLnByaW1hcnlbMl0gOiBDT0xPUlMuZGFya1syXSk7XG4gICAgZG9jLnRleHQodmFsdWUsIFRPVEFMX1ZBTFVFX1gsIHRvdGFsUm93WSwgeyBhbGlnbjogJ3JpZ2h0JyB9KTtcblxuICAgIHRvdGFsUm93WSArPSA3O1xuICB9XG5cbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gIC8vIDcuIE1FTlRJT04gVFZBXG4gIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuXG4gIGNvbnN0IHZhdFkgPSB0b3RhbFJvd1kgKyA0O1xuICBkb2Muc2V0Rm9udFNpemUoNy41KTtcbiAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdpdGFsaWMnKTtcbiAgZG9jLnNldFRleHRDb2xvciguLi5DT0xPUlMuZ3JheSk7XG4gIGNvbnN0IHZhdFRleHQgPVxuICAgIHRlbmFudC52YXRNZW50aW9uID8/XG4gICAgXCIqVFZBIG5vbiBhcHBsaWNhYmxlLCBlbiBhcHBsaWNhdGlvbiBkZSBsJ2FydGljbGUgMjkzQiBkdSBDb2RlIEfDqW7DqXJhbCBkZXMgSW1ww7R0c1wiO1xuICBjb25zdCB2YXRMaW5lcyA9IGRvYy5zcGxpdFRleHRUb1NpemUodmF0VGV4dCwgQ09OVEVOVF9XKTtcbiAgZG9jLnRleHQodmF0TGluZXMsIE1BUkdJTiwgdmF0WSk7XG5cbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gIC8vIDguIFBJRUQgREUgUEFHRSDigJQgXCJNRVJDSSAhXCIgKyBjb29yZG9ubsOpZXNcbiAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG5cbiAgY29uc3QgRk9PVEVSX1kgPSBQSCAtIDI4O1xuXG4gIC8vIFRyYWl0IGRlIHPDqXBhcmF0aW9uXG4gIGRvYy5zZXREcmF3Q29sb3IoLi4uQ09MT1JTLmdvbGQpO1xuICBkb2Muc2V0TGluZVdpZHRoKDAuOCk7XG4gIGRvYy5saW5lKE1BUkdJTiwgRk9PVEVSX1kgLSA0LCBQVyAtIE1BUkdJTiwgRk9PVEVSX1kgLSA0KTtcblxuICBkb2Muc2V0Rm9udFNpemUoMTMpO1xuICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ2JvbGQnKTtcbiAgZG9jLnNldFRleHRDb2xvciguLi5DT0xPUlMuZGFyayk7XG4gIGRvYy50ZXh0KCdNRVJDSSAhJywgUFcgLyAyLCBGT09URVJfWSArIDQsIHsgYWxpZ246ICdjZW50ZXInIH0pO1xuXG4gIC8vIENvb3Jkb25uw6llc1xuICBjb25zdCBmb290ZXJQYXJ0czogc3RyaW5nW10gPSBbXTtcbiAvLyBpZiAodGVuYW50LmFkZHJlc3MxKSBmb290ZXJQYXJ0cy5wdXNoKHRlbmFudC5hZGRyZXNzMSk7XG4gZm9vdGVyUGFydHMucHVzaChcIkdpc2VsbGUgQnJhbmQgQWdlbmN5IC0gUGFsYXZhcy1MZXMtRmxvdHMgLSBoZWxsby5naXNlbGxlYnJhbmRhZ2VuY3lAb3V0bG9vay5mclwiKTtcblxuXG4gIGRvYy5zZXRGb250U2l6ZSg4KTtcbiAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgZG9jLnNldFRleHRDb2xvciguLi5DT0xPUlMuZ3JheSk7XG4gIGRvYy50ZXh0KGZvb3RlclBhcnRzLmpvaW4oJyAg4oCiICAnKSwgUFcgLyAyLCBGT09URVJfWSArIDEwLCB7IGFsaWduOiAnY2VudGVyJyB9KTtcblxuICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgLy8gOS4gVMOJTMOJQ0hBUkdFTUVOVFxuICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuICBjb25zdCBmaWxlbmFtZSA9IGBGYWN0dXJlXyR7aW52b2ljZU51bWJlcn1fJHtzdWJzY3JpcHRpb24ub2ZmZXJOYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX0ucGRmYDtcbiAgZG9jLnNhdmUoZmlsZW5hbWUpO1xufVxuXG4vLyDilIDilIDilIAgSGVscGVycyBpbnRlcm5lcyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuZnVuY3Rpb24gX2RyYXdUYWJsZUhlYWRlcihcbiAgZG9jOiBqc1BERixcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGNvbHM6IG51bWJlcltdLFxuICBoZWFkZXJzOiBzdHJpbmdbXVxuKTogdm9pZCB7XG4gIGNvbnN0IFJPV19IID0gODtcbiAgbGV0IGN4ID0geDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGb25kIGphdW5lXG4gICAgZG9jLnNldEZpbGxDb2xvciguLi5DT0xPUlMuZ29sZCk7XG4gICAgZG9jLnJlY3QoY3gsIHksIGNvbHNbaV0sIFJPV19ILCAnRicpO1xuXG4gICAgLy8gQm9yZHVyZVxuICAgIGRvYy5zZXREcmF3Q29sb3IoMjAwLCAxOTAsIDQwKTtcbiAgICBkb2Muc2V0TGluZVdpZHRoKDAuMik7XG4gICAgZG9jLnJlY3QoY3gsIHksIGNvbHNbaV0sIFJPV19ILCAnUycpO1xuXG4gICAgLy8gVGV4dGUgY2VudHLDqVxuICAgIGRvYy5zZXRGb250U2l6ZSg4LjUpO1xuICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnYm9sZCcpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoLi4uQ09MT1JTLmRhcmspO1xuICAgIGRvYy50ZXh0KGhlYWRlcnNbaV0sIGN4ICsgY29sc1tpXSAvIDIsIHkgKyA1LjIsIHsgYWxpZ246ICdjZW50ZXInIH0pO1xuXG4gICAgY3ggKz0gY29sc1tpXTtcbiAgfVxufVxuLypcbmZ1bmN0aW9uIF9kcmF3VGFibGVSb3coXG4gIGRvYzoganNQREYsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBjb2xzOiBudW1iZXJbXSxcbiAgdmFsdWVzOiBzdHJpbmdbXVxuKTogdm9pZCB7XG4gIGNvbnN0IFJPV19IID0gODtcbiAgbGV0IGN4ID0geDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGb25kIGJsYW5jIGzDqWdlclxuICAgIGRvYy5zZXRGaWxsQ29sb3IoLi4uQ09MT1JTLndoaXRlKTtcbiAgICBkb2MucmVjdChjeCwgeSwgY29sc1tpXSwgUk9XX0gsICdGJyk7XG5cbiAgICAvLyBCb3JkdXJlIGZpbmVcbiAgICBkb2Muc2V0RHJhd0NvbG9yKDIyMCwgMjIwLCAyMjApO1xuICAgIGRvYy5zZXRMaW5lV2lkdGgoMC4xNSk7XG4gICAgZG9jLnJlY3QoY3gsIHksIGNvbHNbaV0sIFJPV19ILCAnUycpO1xuXG4gICAgLy8gVGV4dGUgKGF2ZWMgd3JhcCBzaSBuw6ljZXNzYWlyZSlcbiAgICBkb2Muc2V0Rm9udFNpemUoOC41KTtcbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ25vcm1hbCcpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoLi4uQ09MT1JTLmRhcmspO1xuXG4gICAgY29uc3QgYWxpZ24gPSBpID09PSAwID8gJ2NlbnRlcicgOiBpID49IGNvbHMubGVuZ3RoIC0gMiA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgY29uc3QgdGV4dFggPVxuICAgICAgYWxpZ24gPT09ICdjZW50ZXInID8gY3ggKyBjb2xzW2ldIC8gMiA6IGFsaWduID09PSAncmlnaHQnID8gY3ggKyBjb2xzW2ldIC0gMiA6IGN4ICsgMjtcblxuICAgIC8vIFdyYXAgc3VyIGxhIGNvbG9ubmUgZGVzY3JpcHRpb24gKGluZGV4IDEgZGFucyBsZSAyZSB0YWJsZWF1KVxuICAgIGlmICh2YWx1ZXNbaV0ubGVuZ3RoID4gMzAgJiYgY29sc1tpXSA+IDUwKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IGRvYy5zcGxpdFRleHRUb1NpemUodmFsdWVzW2ldLCBjb2xzW2ldIC0gNCk7XG4gICAgICBkb2MudGV4dChsaW5lc1swXSwgdGV4dFgsIHkgKyA1LjIsIHsgYWxpZ24gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvYy50ZXh0KHZhbHVlc1tpXSwgdGV4dFgsIHkgKyA1LjIsIHsgYWxpZ24gfSk7XG4gICAgfVxuXG4gICAgY3ggKz0gY29sc1tpXTtcbiAgfVxufSovXG5cbmZ1bmN0aW9uIF9kcmF3VGFibGVSb3coXG4gIGRvYzoganNQREYsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBjb2xzOiBudW1iZXJbXSxcbiAgdmFsdWVzOiBzdHJpbmdbXVxuKTogdm9pZCB7XG4gIGNvbnN0IFJPV19IID0gODtcbiAgbGV0IGN4ID0geDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHMubGVuZ3RoOyBpKyspIHtcbiAgICBkb2Muc2V0RmlsbENvbG9yKC4uLkNPTE9SUy53aGl0ZSk7XG4gICAgZG9jLnJlY3QoY3gsIHksIGNvbHNbaV0sIFJPV19ILCAnRicpO1xuICAgIGRvYy5zZXREcmF3Q29sb3IoMjIwLCAyMjAsIDIyMCk7XG4gICAgZG9jLnNldExpbmVXaWR0aCgwLjE1KTtcbiAgICBkb2MucmVjdChjeCwgeSwgY29sc1tpXSwgUk9XX0gsICdTJyk7XG5cbiAgICBkb2Muc2V0Rm9udFNpemUoOCk7IC8vIFRhaWxsZSBsw6lnw6hyZW1lbnQgcsOpZHVpdGUgcG91ciBsYSBzw6ljdXJpdMOpXG4gICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKC4uLkNPTE9SUy5kYXJrKTtcblxuICAgIC8vIETDqXRlcm1pbmF0aW9uIGRlIGwnYWxpZ25lbWVudFxuICAgIGNvbnN0IGFsaWduID0gKGkgPT09IDAgfHwgaSA9PT0gMSkgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIGNvbnN0IHRleHRYID0gYWxpZ24gPT09ICdsZWZ0JyA/IGN4ICsgMiA6IGN4ICsgY29sc1tpXSAtIDI7XG5cbiAgICAvLyBHZXN0aW9uIGR1IHRleHRlIGxvbmcgKERlc2NyaXB0aW9uKVxuICAgIGNvbnN0IG1heFdpZHRoID0gY29sc1tpXSAtIDQ7XG4gICAgY29uc3QgdGV4dExpbmVzID0gZG9jLnNwbGl0VGV4dFRvU2l6ZSh2YWx1ZXNbaV0sIG1heFdpZHRoKTtcbiAgICBcbiAgICAvLyBPbiBuJ2FmZmljaGUgcXVlIGxhIHByZW1pw6hyZSBsaWduZSBzaSDDp2EgZMOpcGFzc2UsIFxuICAgIC8vIG91IG9uIHLDqWR1aXQgbGEgcG9saWNlIHNpIGMnZXN0IGxhIGRlc2NyaXB0aW9uXG4gICAgaWYgKHRleHRMaW5lcy5sZW5ndGggPiAxICYmIGkgPT09IDEpIHtcbiAgICAgICAgZG9jLnNldEZvbnRTaXplKDcpO1xuICAgIH1cbiAgICBcbiAgICBkb2MudGV4dCh0ZXh0TGluZXNbMF0sIHRleHRYLCB5ICsgNS4yLCB7IGFsaWduIH0pO1xuXG4gICAgY3ggKz0gY29sc1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbWFwUGF5bWVudE1ldGhvZChtZXRob2Q/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBtYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgY2FydGVfYmFuY2FpcmU6ICdDYXJ0ZSBiYW5jYWlyZScsXG4gICAgdmlyZW1lbnQ6ICdWaXJlbWVudCBiYW5jYWlyZScsXG4gICAgcHJlbGV2ZW1lbnQ6ICdQcsOpbMOodmVtZW50IGF1dG9tYXRpcXVlJyxcbiAgICBjaGVxdWU6ICdDaMOocXVlJyxcbiAgICBub25fc3BlY2lmaWU6ICdEw7sgw6AgcsOpY2VwdGlvbiBkZSBsYSBmYWN0dXJlJyxcbiAgfTtcbiAgcmV0dXJuIG1hcFttZXRob2QgPz8gJyddID8/ICdEw7sgw6AgcsOpY2VwdGlvbiBkZSBsYSBmYWN0dXJlJztcbn1cbiJdLCJuYW1lcyI6WyJqc1BERiIsIkNPTE9SUyIsImdvbGQiLCJnb2xkTGlnaHQiLCJkYXJrIiwiZ3JheSIsImxpZ2h0R3JheSIsIndoaXRlIiwicHJpbWFyeSIsImZvcm1hdERhdGUiLCJkYXRlU3RyIiwibG9jYWxlIiwiZCIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJkYXkiLCJtb250aCIsInllYXIiLCJmb3JtYXRDdXJyZW5jeSIsImFtb3VudCIsInRvRml4ZWQiLCJ6ZXJvUGFkIiwibnVtIiwic2l6ZSIsIlN0cmluZyIsInBhZFN0YXJ0IiwiZ2VuZXJhdGVJbnZvaWNlUGRmIiwic3Vic2NyaXB0aW9uIiwidGVuYW50Iiwib3B0aW9ucyIsImRvYyIsIm9yaWVudGF0aW9uIiwidW5pdCIsImZvcm1hdCIsIlBXIiwiaW50ZXJuYWwiLCJwYWdlU2l6ZSIsImdldFdpZHRoIiwiUEgiLCJnZXRIZWlnaHQiLCJNQVJHSU4iLCJDT05URU5UX1ciLCJpbnZvaWNlTnVtYmVyIiwiaWQiLCJOdW1iZXIiLCJwYXltZW50QW1vdW50IiwiZGVzY3JpcHRpb24iLCJvZmZlck5hbWUiLCJzdWJzY3JpcHRpb25TdGFydERhdGUiLCJzdWJzY3JpcHRpb25FbmREYXRlIiwiZGF5c1N1YnNjcmliZWQiLCJsb2dvQmFzZTY0IiwiYWRkSW1hZ2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwic2V0RmlsbENvbG9yIiwicm91bmRlZFJlY3QiLCJzZXRGb250U2l6ZSIsInNldEZvbnQiLCJzZXRUZXh0Q29sb3IiLCJ0ZXh0IiwiYWxpZ24iLCJoZWFkZXJCb3R0b20iLCJsZWZ0WSIsInJpZ2h0WSIsIk1FVEFfTEFCRUxfWCIsIk1FVEFfVkFMVUVfWCIsIm1ldGFSb3dzIiwicGF5bWVudERhdGUiLCJjb21wYW55TmFtZSIsImxhYmVsIiwidmFsdWUiLCJiaWxsaW5nWSIsIk1hdGgiLCJtYXgiLCJjbGllbnRMaW5lcyIsInB1c2giLCJhZGRyZXNzMSIsImFkZHJlc3MyIiwicGhvbmUiLCJlbWFpbCIsImNsaWVudFkiLCJsaW5lIiwiVEFCTEUxX1kiLCJST1dfSCIsIlRBQkxFMV9DT0xTIiwiVEFCTEUxX0hFQURFUlMiLCJfZHJhd1RhYmxlSGVhZGVyIiwicGF5bWVudENvbmRpdGlvbiIsIl9tYXBQYXltZW50TWV0aG9kIiwicGF5bWVudE1ldGhvZCIsImR1ZURhdGUiLCJfZHJhd1RhYmxlUm93IiwiVEFCTEUyX1kiLCJUQUJMRTJfQ09MUyIsIlRBQkxFMl9IRUFERVJTIiwiVE9UQUxfWSIsIlRPVEFMX1ZBTFVFX1giLCJUT1RBTF9MQUJFTF9YIiwidG90YWxzUm93cyIsInRvdGFsUm93WSIsImlzQm9sZCIsInJlY3QiLCJ2YXRZIiwidmF0VGV4dCIsInZhdE1lbnRpb24iLCJ2YXRMaW5lcyIsInNwbGl0VGV4dFRvU2l6ZSIsIkZPT1RFUl9ZIiwic2V0RHJhd0NvbG9yIiwic2V0TGluZVdpZHRoIiwiZm9vdGVyUGFydHMiLCJqb2luIiwiZmlsZW5hbWUiLCJyZXBsYWNlIiwic2F2ZSIsIngiLCJ5IiwiY29scyIsImhlYWRlcnMiLCJjeCIsImkiLCJsZW5ndGgiLCJ2YWx1ZXMiLCJ0ZXh0WCIsIm1heFdpZHRoIiwidGV4dExpbmVzIiwibWV0aG9kIiwibWFwIiwiY2FydGVfYmFuY2FpcmUiLCJ2aXJlbWVudCIsInByZWxldmVtZW50IiwiY2hlcXVlIiwibm9uX3NwZWNpZmllIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils/generateInvoicePdf.ts\n"));

/***/ })

});